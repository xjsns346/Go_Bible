

# MarkDown 要点:
1. ctrl + shift + v   可以在vs code 预览文件效果
2. ``` 代码 ```  来展示多行代码。
3. 写完一行之后加上两个空格，就可以实现换行效果。



# GO中常见的错误

1. `expected '{', found 'func'`错误。  

 | 可能原因                  | 示例（错误代码）                                                                                               | 错误说明                                | 正确写法                                                                                                                                                                                               |
| --------------------- | ------------------------------------------------------------------------------------------------------ | ----------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1️⃣ 函数声明缺少 `{`**    | `go<br>func main()<br>    fmt.Println("Hi")<br>`                                                       | Go 期望在函数声明后立即看到 `{`                 | `go<br>func main() {<br>    fmt.Println("Hi")<br>}<br>`                                                                                                                                            |
| **2️⃣ 在函数体中定义函数（非法）** | `go<br>func main() {<br>    func inner() {<br>        fmt.Println("inner")<br>    }<br>}<br>`          | Go 不允许在函数内部定义具名函数                   | ✅ 使用匿名函数：<br>`go<br>func main() {<br>    inner := func() {<br>        fmt.Println("inner")<br>    }<br>    inner()<br>}<br>`<br>或定义在外部：<br>`go<br>func inner() { ... }<br>func main() { inner() }` |
| **3️⃣ 花括号 `{}` 未匹配**  | `go<br>type IntSet struct {<br>    words []uint64<br><br>func (s *IntSet) String() string { ... }<br>` | `type` 块未正确关闭，导致编译器把 `func` 当作结构体字段 | `go<br>type IntSet struct {<br>    words []uint64<br>}<br><br>func (s *IntSet) String() string { ... }<br>`                                                                                        |
| **4️⃣ 上下文语法不完整**      | `go<br>if true<br>func f() {}<br>`                                                                     | 控制语句后缺 `{`，编译器误解结构                  | `go<br>if true {<br>    fmt.Println("ok")<br>}<br>`                                                                                                                                                |



# Go模块系统

## go.mod 是什么
1. go.mod 是 Go 模块系统的核心配置文件。
它的作用是:记录当前项目的模块路径、Go 版本、依赖包及其版本。
2. Go 从 1.11 开始引入模块（module）系统，用来取代 GOPATH 机制。

3. 
| 功能               | 说明                                  |
| :--- | :---|
| **1️⃣ 声明模块名**    | 指定当前项目的唯一模块路径（通常对应仓库路径）             |
| **2️⃣ 管理依赖版本**   | 明确记录项目依赖了哪些包及其版本                    |
| **3️⃣ 控制替换规则**   | 可用 `replace` 或 `exclude` 手动修改依赖源或版本 |
| **4️⃣ 指定 Go 版本** | 确保代码按指定 Go 版本语义编译                   |
| **5️⃣ 支持可重复构建**  | 不论谁在哪个机器上构建，都能获得相同的依赖和结果            |


4. 常见命令与 go.mod 的关系

| 命令 |	作用 |
| :--- | :--- |
|**go mod init <module-name>**|	创建 go.mod 文件并初始化模块|
|**go mod tidy**|自动添加缺失的依赖，删除未使用的依赖|
|**go mod download**|	下载 go.mod 里列出的依赖|
|**go mod edit**|	手动编辑 go.mod 内容（高级用法）|

5. 配套文件：go.sum
Go 会自动生成一个 go.sum 文件，用来记录每个依赖模块的哈希值。
它保证每次下载的依赖都完全一致，防止被篡改。



# Go 学习笔记



## 入门

gofmt工具格式化时按照字母顺序对包名排序。  

Go语言只有for循环这一种循环语句。

空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。

当你运行 go run xxx.go 的时候，Go 会先 编译 .go 文件 → 生成一个 .exe → 把它放到 AppData\Local\go-build 这个缓存目录。
这个.exe文件是一个临时可执行文件，下次运行.go文件时会创建一个新的.exe文件

map的迭代顺序并不确定,类似于python的字典类型

os.Stdin,os.Stdout,os.Stderr都是*os.file类型的值

程序员通常不需要关心 int/uint 的精确大小，只要用它们表示“一般整数”就行。
当处理网络协议、文件格式时，才用 int32、uint16 等。

### 查找重复的行
-小文件（配置文件、少量数据） → os.ReadFile，简单方便。
-大文件（日志、数据集） → bufio.Scanner 或 bufio.Reader，节省内存。  

在 Go 里，只有 package main 且包含 func main() 函数的包，才能编译成一个可执行文件。

### 获取URL
在同一作用域里，:= 遇到旧变量时：
1.如果左边有新变量 → 旧变量被复用，新变量被定义。
2.如果左边全是旧变量 → 编译报错。

| 特性         | `io.ReadAll`           | `io.Copy`            |
| --- | --- | --- |
| 返回结果*  | `[]byte`（全部数据）         | 字节数（已写到 `dst`）       |
| 内存占用* | 和数据大小成正比，可能很大          | 固定缓冲区（约 32KB）        |
| 适用场景   | 小文件、小 HTTP 响应，结果需要直接操作 | 大文件、大流式数据，结果要写到文件/网络 |
| 是否阻塞内存 | 是，会占住内存直到数据全读完         | 否，边读边写，流式处理          |


## 程序结构

### 类型
许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印，但是当使用%g时，不会调用string方法。
在圣经的例子中，%g没有调用string方法，因为%g 专门用于 浮点数格式化，而不是通用字符串格式化。


### 变量
flag 包就是 Go 官方提供的 命令行参数解析工具，适合写小工具、脚本或服务时用来配置参数。  

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这个选择并不是由用var还是new声明变量的方式决定的。

### 包和文件

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释,如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释。如果包注释很大，通常会放到一个独立的doc.go文件中。

一个目录下的所有 .go 文件必须属于同一个包。

在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

按照惯例，一个包的名字和包的导入路径的最后一个字段相同。

当一个较大位宽的整数类型转换为较小位宽时，高位会被截断，只保留低位。



## 基础数据类型

### 整型

取模运算符%仅用于整数间的运算。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。  

x &^ y 的作用就是：把 x 里，y 为 1 的位置清零，其他位置保持不变。(二进制)

1. 左移运算符 <<
表达式：x << n
含义：把 x 的二进制位整体 向左移动 n 位，右边空出来的位用 0 填充。
👉 数学效果：相当于 乘以 2ⁿ（前提是不溢出）。

2. 右移运算符 >>
表达式：x >> n
含义：把 x 的二进制位整体 向右移动 n 位。
左边空出来的位，规则要分情况：
无符号整数：高位补 0（逻辑右移）。
有符号整数：Go 里会补 符号位（算术右移）。
👉 数学效果：相当于 除以 2ⁿ，取整。  

|名称|符号|
|---|---|
|AND|&|
|OR|\||
|XOR|^|
|左移|<<|
|右移|>>|

## 字符串
1. strings.Map(mapping,string)是一个对处理字符串非常方便的函数。

2. Go 中的 string 是：
```go
  type string struct {
    data *byte   // 指向底层字节数组
    len  int     // 字节长度
  }
```
也就是说，字符串就是UTF-8 编码的字节序列。
每个字符（Unicode code point）被编码为 1~4 个字节。

3. 对字符串使用len函数时的一些误区:
- len(s1)：返回的是字节数，因为 Go 中的字符串是以字节的方式存储的。
- range 遍历：range 在遍历字符串时，会自动将每个字符转换成 rune，因此你可以直接得到每个 Unicode 字符（rune）及其对应的字节索引（i）。
- 转换为 rune 切片：你可以将字符串转换为 []rune 切片来更方便地按字符访问，因为每个 rune 都代表一个完整的 Unicode 字符。

### *有关字符串存储与打印的一些小知识*
由于世界上的语言繁多，以及存在大量符号，原有的 ASCII 编码（仅 128 个字符）无法满足需求，因此产生了 Unicode 标准，为世界上每个字符分配了唯一的 码点（Code Point）。

Unicode 码点的范围是从 U+0000 到 U+10FFFF，最多需要 21 位二进制表示。为了方便实现，许多语言（如 Go 的 rune）用 32 位整数存储码点。

为了在存储和传输中节约空间，Unicode 引入了多种编码方式，其中最常用的是 UTF-8。UTF-8 使用 1~4 个字节表示一个码点：
对 ASCII 范围内的字符使用 1 字节，与 ASCII 完全兼容；
对其他字符使用 2~4 字节，既节约空间，又能自我同步。

编码后，字符被存储为一串字节（[]byte）。要恢复原始字符，就需要解码这些字节得到对应的码点（rune）。

当我们输出字符时，程序会把 rune 重新编码为 UTF-8 字节写入标准输出流。终端程序读取这些字节，解码出码点后，根据系统字体库查找该码点对应的字形（glyph），再通过字体渲染引擎绘制到屏幕上。这样，字符最终以像素的形式呈现在我们面前。

* * *

## 复合数据类型

### Slice
1. 并行赋值的执行顺序：先计算右侧所有表达式的值，并将它们暂时存储在临时变量中。再将这些临时值依次赋给左侧变量。(用于反转数据)

2. unicode.IsSpace(rune) : 当你传入9，10，11，32时均会返回True，因为根据Unicode它们对应的符号均为空格。

3. Go 的设计者刻意去掉了指针算术，原因是为了：保证内存安全；避免非法访问；使垃圾回收器更容易跟踪引用。

4. Go 的切片传参是「值传递」而非「引用传递」当你把一个切片传入函数时，Go 会 拷贝这个结构体，但它的 array 指针仍然指向同一个底层数组。

-  底层数组是共享的 
- 切片的 len 和 cap 是独立副本 
- Go 的切片底层结构大致如下：
```go
type slice struct {
    array unsafe.Pointer // 底层数组指针
    len   int
    cap   int
}
```

5. 当使用append方法时，有一些注意事项:
  - append 的基本语法`slice = append(slice, elem1, elem2, ...)`
第一个参数：要被扩展的切片（可以为 nil）。
后续参数：要追加的一个或多个元素。
返回值是一个新的切片（可能共用原底层数组，也可能新建）。
  - 使用 ... 展开符：append(a, b...) 表示把切片 b 的所有元素展开后逐一追加。
  - Go 在底层做了容量增长优化：当 cap < 1024 时：通常是 翻倍增长；当 cap >= 1024 时：增长率约为 1.25倍（即 +25%）。


### MAP详解

---

1. map 的本质结构

在 Go 源码中（`src/runtime/map.go`），map 的核心结构是一个 `hmap`：

```go
type hmap struct {
    count     int            // 当前元素个数
    flags     uint8          // 状态标志
    B         uint8          // 2^B = 桶数量
    noverflow uint16         // 溢出桶数量
    hash0     uint32         // 哈希种子，用于防御攻击
    buckets    unsafe.Pointer // 主桶数组（bmap 数组）
    oldbuckets unsafe.Pointer // 扩容时旧桶的数组
    nevacuate  uintptr       // 扩容进度标记
}
```

🔹 每个 `map` 都维护着一个 **桶（bucket）数组**。
🔹 每个桶（`bmap`）里面存储若干个键值对（key/value）。
🔹 键值根据 **哈希函数** 被分配到某个桶中。

---

2. bmap（桶）结构

在底层，一个桶（bucket）大致长这样（伪结构）：

```go
type bmap struct {
    tophash [8]uint8   // 哈希值高8位，用于快速比较
    keys    [8]KeyType // 键数组
    values  [8]ValueType // 值数组
    overflow *bmap     // 溢出桶指针
}
```

> 实际上在源码里，`bmap` 是通过不定长结构 + 位运算实现的，但逻辑上等价于上面形式。

每个桶可容纳 **最多 8 个键值对**。
当桶装满后，再放入新元素时，会创建一个 **溢出桶**，通过 `overflow` 指针链起来。

---

3. 插入元素的过程（Put）

当我们执行：

```go
m["foo"] = 42
```

Go 做了以下事情：

1. **计算哈希值**

   ```go
   hash := hash("foo") ^ hmap.hash0
   ```

   `hash0` 是随机种子，防止哈希碰撞攻击。

2. **定位桶**

   ```go
   bucketIndex := hash & (2^B - 1)
   ```

   取低 B 位确定桶位置。

3. **桶内查找空位**

   * 对比 `tophash`（哈希高 8 位）
   * 若找到空槽位 → 写入 key/value。
   * 若桶满 → 创建溢出桶并链接。

4. **如果负载因子过大（约 6.5）→ 触发扩容。**

---

4. 扩容机制（Rehashing）

当桶太多或太满，Go 会 **渐进式扩容**：

1. 创建一个新 `buckets`，大小是旧的 2 倍；
2. `oldbuckets` 暂时保留；
3. 每次插入或访问时，**搬迁一部分旧桶数据**；
4. 当所有旧桶搬完后，才彻底释放旧数据。

➡️ 所以扩容是渐进完成的，不会一次性卡顿。

---

5. 取值过程（Get）

当执行：

```go
v := m["foo"]
```

过程如下：

1. 计算哈希；
2. 定位桶；
3. 比对桶内的 `tophash`；
4. 若匹配，再比较真实 key；
5. 若命中返回 value，否则到溢出桶继续找；
6. 若未找到，返回零值。

---

6. 删除（Delete）

`delete(m, key)`：

* 找到目标桶；
* 若匹配到 key，则把对应 `tophash` 标记为空（即删除）；
* 不会立刻缩容。

---

7. map 的引用特性来源

`map` 变量中保存的其实是一个 **指向 `hmap` 的指针**，所以：

* 当你把 `map` 传给函数时，只是复制了这根“指针”；
* 对底层 buckets 的修改都可见；
* 但若你把这根指针改掉（`m = nil`），外部不受影响。

---

8. 简图助理解（逻辑结构）

```
m ──► hmap ──► buckets ──► [bmap0]─►[bmap1]─►[bmap2] ...
               │
               └──► oldbuckets (扩容时存在)
```

每个 `[bmap]`：

```
tophash: [aa bb cc ..]
keys:    [k1 k2 k3 ..]
values:  [v1 v2 v3 ..]
overflow: ──► 另一个 bmap（若满）
```

---

9. 小结表格

| 项目     | 内容           |
| ------ | ------------ |
| map 本质 | 指向 hmap 的指针  |
| 桶数量    | 2^B          |
| 每桶最多元素 | 8            |
| 负载因子阈值 | ≈6.5         |
| 扩容方式   | 渐进式 rehash   |
| 传参特性   | 值传递 + 共享底层数据 |
| 并发安全性  | ❌ 不安全（需加锁）   |





###  结构体  
  
  对于结构体的指针，可以直接使用点操作符，编译器会自动调用解引用。  

  一个结构体可能同时包含导出和未导出的成员。如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。


### JSON

将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。
在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。




## 函数


### 函数命名

函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。
函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。
每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参。
遇到没有函数体的函数声明，这表示该函数不是以Go实现的。


### 递归

有关outline函数，传入了一个string切片，命名为stack,当作栈来使用，这是可行的，因为切片的删除操作可以模仿栈的后入先出，在Golang中没有特定的栈类型
需要注意的是：有关切片被作为参数传入的时候，是值传递的方式传递的，切片内部的len,app是复制的，但是底层的数组指针还是指向同一个数组，但是当使用切片的
append操作时，**如果超出了切片的cap，那么就会重新分配数组，这个时候，函数内部的切片就和原切片无关了，因为此时他们指向不同的数组。**


### 多返回值

strings.Fields 是 Go 标准库 strings 包中的一个函数，作用是：按照空白字符切分字符串，并返回一个字符串切片。
它的行为类似于其他语言里的 split()，但更智能：会自动识别各种空白字符（空格、换行符、制表符等），并且自动忽略多余的空白


### 错误

1.在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。

2.对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。
如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。

3.error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。

4.**有少部分函数在发生错误时，仍然会返回一些有用的返回值**。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。

5.编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。


### 函数值

### 函数值的底层实现机制
1.Go 的函数值在本质上是一个轻量级的函数指针封装结构，Go 的函数值是一个指向函数代码的引用结构，内部保存代码地址（fn）和可选的环境指针（env）。

2.函数值结构中存储着一个函数指针(fn)，指向实际可执行代码的位置，当函数“捕获”外部变量时（比如返回一个内部函数），
这个函数值不仅要保存代码地址，还要保存被捕获的变量环境(env)。并且GO的闭包并不是复制外部变量的值，其实是引用外部变量的地址。
当形成闭包时，捕获的外部变量会被移动到堆上，并由 env 指针引用。调用闭包时，会额外传入环境指针，实现“记忆状态”的能力。

3.闭包捕获的是变量地址，而不是值。因此多个闭包共享同一个外部变量时，会互相影响。

4.编译器有时会对 不捕获变量的匿名函数 做静态化优化，
使其行为与普通函数几乎相同（不分配 env）。Go 函数调用支持 内联（inline）优化，
即使是函数值调用，只要编译器能确定 fn 指向的函数体，也可能内联。

5.底层实现结构大致如下:
```go
type closure struct {
    fn uintptr       // 指向函数代码
    env *environment // 指向捕获的变量环境
}

type environment struct {
    count *int
}

```

### 有关nil与空切片的区别
nil 切片：ptr == nil，len == 0，cap == 0
空切片：ptr 指向某个零长度数组（地址非空），len == 0，cap == 0
并且GO遵从‘零值可用’原则，对nil与空切片进行range循环，均不会报错，会直接退出循环。
``` go
a := []string//a为nil
b := []string{}//b为空切片
c := make([]string,0)//c为空切片
```

### 匿名函数

1.  `link, err := resp.Request.URL.Parse(a.Val)` 这一行代码很常见，尤其在编写网络爬虫或解析 HTML 链接时经常出现。
    作用: 基于当前网页的 URL，解析 HTML 标签中的相对链接，生成完整的绝对 URL。


2. Go 的 `for d := range dirs` 循环中，d 变量在每次迭代中是被重用的，不是每次新建一个。所以当闭包中需要调用变量**d**的时候，要创建一个新的变量来储存*d*的值


### 可变参数

1. 变长参数`...`只能出现在函数的参数列表的最后一个位置。如果你在其他位置（比如中间或开头）使用 `...`，就会出现这个错误。

  原因:Go 语言的参数列表是按顺序解析的。固定参数会先被解析，而变长参数（...）必须位于最后，因为它表示“剩下的所有参数”。这确保了 Go 编译器可以正确区分固定数量的参数和变长参数，并将多余的参数放入切片中。如果将 ... 放在中间或开头，编译器就无法确定哪些是固定的参数，哪些是变长参数，因此会报错。


2. 


### Defer

1. defer 是在 return 值已经准备好以后才执行,所以 defer 里的操作可以修改命名返回值！

2. Go 在编译期会把 defer call 放进一个 defer 栈（stack） 中，执行顺序遵循栈结构逻辑。

3. defer语句执行时机:
      | 顺序 | 发生阶段描述 |
      |---|---|
      | 1 | 执行到 `return` 语句（准备返回） |
      | 2 | **return 的返回值先被计算、更新（若有命名返回值则先赋值到该变量）** |
      | 3 | 执行所有 `defer` 注册的函数（**后 defer 先执行：LIFO**） |
      | 4 | 完成函数返回，将最终结果返回给调用者 |



### panic,defer,recover三者联系。

1. 当一个 panic 发生时，Go runtime 会开始向上展开栈（stack unwinding）

2. 在展开当前函数栈时，会先执行这个函数中已经注册好的 defer，按照 FILO 顺序执行

3. 如果在 defer 中调用 recover() 并且成功捕获 panic，那么 panic 被阻止继续向上传播

4. 在 recover 那一瞬间，函数的控制权会恢复到正常 return 路径，并且 panic 触发位置之后的语句不会再继续执行


## 方法

### 方法声明

1. Go 规定：方法名和字段名属于同一个命名空间。

2. 在GO语言中，我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者interface。

3. 下面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。
```go
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```
4. 这种`p.Distance`的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。  
    选择器也会被用来选择一个struct类型的字段，比如p.X。  



###  基于指针对象的方法

1. 如果一个类型的方法中有任何一个是指针接收器，那么全部方法都应当使用指针接收器。  
   这样做的好处：  

  |优点	|说明|
  |----|----|
  |✅ 行为一致|	所有方法都能修改对象本身|
  |✅ 接口实现稳定	|不会因为值/指针不同而无法实现接口|
  |✅ 避免方法集混乱|	Point 与 *Point 方法集一致|
  |✅ 避免性能浪费	|避免大结构体的复制开销|


2. 方法的接收器类型必须是“命名类型”或“命名类型的指针”。  
  在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的。

3. 当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的。


### 通过嵌入结构体来拓展类型
1.  当编译器解析一个选择器到方法时，比如p.ScaleBy，它会首先去找直接定义在这个类型里的ScaleBy方法，然后找被ColoredPoint的内嵌字段们引入的方法，  
  然后去找Point和RGBA的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。

```go
type ColoredPoint struct {
    Point
    color.RGBA
}
```

  | 查找层级  | 查找范围                                                                                  | 说明                                                   |
| ----- | ------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| **1** | 直接定义在 `ColoredPoint` 类型上的方法                                                           | 若有，则直接使用                                             |
| **2** | `ColoredPoint` 的每个内嵌字段的**方法集**                                                        | 即 `Point` 和 `RGBA` 的方法                               |
| **3** | 递归向下：查找这些内嵌字段（如 `Point`、`RGBA`）的**内嵌字段的方法**                                           | 如果 `Point` 里又嵌入了别的类型，比如 `Vec` 或 `Position`，也会进入那一层去找 |
| **4** | 如果在同一级发现了两个同名方法（比如 `Point.ScaleBy` 和 `RGBA.ScaleBy`），则 **报错：二义性（ambiguous selector）** |                                                      |


2. 当你为一个复杂的类型定义了一个String方法时，fmt包就会特殊对待这种类型的值，这样可以让这些类型在打印的时候看起来更加友好，  
  而不是直接打印其原始的值。fmt会直接调用用户定义的String方法。





## 接口

### 接口是合约

1. 一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）。这是一个面向对象的特征。

2. 接口要求的是 “类型的方法”，不是“函数”。需要有“接收器”（receiver）。

3. 方法签名要完全匹配（包括名字），如果方法名不同 ⇒ 不匹配接口。以下面的io.Writer接口为例。

4. io.Writer 的定义非常简单：代码中的a类型就实现了io.Writer接口。
```go
type Writer interface {
	Write(p []byte) (n int, err error)
}

type a int
func (b *a)Write(p []byte) (n int, err error){
  return len(p),nil
}

```  
| 类型   | 示例                            | 能否实现接口 | 说明           |
| ---- | ----------------------------- | ------ | ------------ |
| 结构体  | `MyWriter`                    | ✅      | 最常见方式        |
| 指针类型 | `*MyWriter2`                  | ✅      | 绑定指针方法       |
| 别名类型 | `type MyInt int`              | ✅      | 为基础类型加方法     |
| 函数类型 | `type WriteFunc func([]byte)` | ✅      | 高级技巧，用于回调、装饰 |
