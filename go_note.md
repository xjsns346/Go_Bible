# Go 学习笔记

## MarkDown 要点:
1.ctrl + shift + v   可以在vs code 预览文件效果
2.

## 入门

gofmt工具格式化时按照字母顺序对包名排序。  

Go语言只有for循环这一种循环语句。

空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。

当你运行 go run xxx.go 的时候，Go 会先 编译 .go 文件 → 生成一个 .exe → 把它放到 AppData\Local\go-build 这个缓存目录。
这个.exe文件是一个临时可执行文件，下次运行.go文件时会创建一个新的.exe文件

map的迭代顺序并不确定,类似于python的字典类型

os.Stdin,os.Stdout,os.Stderr都是*os.file类型的值

程序员通常不需要关心 int/uint 的精确大小，只要用它们表示“一般整数”就行。
当处理网络协议、文件格式时，才用 int32、uint16 等。

### 查找重复的行
-小文件（配置文件、少量数据） → os.ReadFile，简单方便。
-大文件（日志、数据集） → bufio.Scanner 或 bufio.Reader，节省内存。  

在 Go 里，只有 package main 且包含 func main() 函数的包，才能编译成一个可执行文件。

### 获取URL
在同一作用域里，:= 遇到旧变量时：
1.如果左边有新变量 → 旧变量被复用，新变量被定义。
2.如果左边全是旧变量 → 编译报错。

| 特性         | `io.ReadAll`           | `io.Copy`            |
| --- | --- | --- |
| 返回结果*  | `[]byte`（全部数据）         | 字节数（已写到 `dst`）       |
| 内存占用* | 和数据大小成正比，可能很大          | 固定缓冲区（约 32KB）        |
| 适用场景   | 小文件、小 HTTP 响应，结果需要直接操作 | 大文件、大流式数据，结果要写到文件/网络 |
| 是否阻塞内存 | 是，会占住内存直到数据全读完         | 否，边读边写，流式处理          |


## 程序结构

### 类型
许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印，但是当使用%g时，不会调用string方法。
在圣经的例子中，%g没有调用string方法，因为%g 专门用于 浮点数格式化，而不是通用字符串格式化。


### 变量
flag 包就是 Go 官方提供的 命令行参数解析工具，适合写小工具、脚本或服务时用来配置参数。  

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这个选择并不是由用var还是new声明变量的方式决定的。

### 包和文件

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释,如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释。如果包注释很大，通常会放到一个独立的doc.go文件中。

一个目录下的所有 .go 文件必须属于同一个包。

在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

按照惯例，一个包的名字和包的导入路径的最后一个字段相同。

当一个较大位宽的整数类型转换为较小位宽时，高位会被截断，只保留低位。



## 基础数据类型

### 整型

取模运算符%仅用于整数间的运算。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。  

x &^ y 的作用就是：把 x 里，y 为 1 的位置清零，其他位置保持不变。(二进制)

1. 左移运算符 <<
表达式：x << n
含义：把 x 的二进制位整体 向左移动 n 位，右边空出来的位用 0 填充。
👉 数学效果：相当于 乘以 2ⁿ（前提是不溢出）。

2. 右移运算符 >>
表达式：x >> n
含义：把 x 的二进制位整体 向右移动 n 位。
左边空出来的位，规则要分情况：
无符号整数：高位补 0（逻辑右移）。
有符号整数：Go 里会补 符号位（算术右移）。
👉 数学效果：相当于 除以 2ⁿ，取整。  

|名称|符号|
|---|---|
|AND|&|
|OR|\||
|XOR|^|
|左移|<<|
|右移|>>|

## 字符串
1.strings.Map(mapping,string)是一个对处理字符串非常方便的函数。

2.Go 中的 string 是：
```go
  type string struct {
    data *byte   // 指向底层字节数组
    len  int     // 字节长度
  }
```
也就是说，字符串就是UTF-8 编码的字节序列。
每个字符（Unicode code point）被编码为 1~4 个字节。

### *有关字符串存储与打印的一些小知识*
由于世界上的语言繁多，以及存在大量符号，原有的 ASCII 编码（仅 128 个字符）无法满足需求，因此产生了 Unicode 标准，为世界上每个字符分配了唯一的 码点（Code Point）。

Unicode 码点的范围是从 U+0000 到 U+10FFFF，最多需要 21 位二进制表示。为了方便实现，许多语言（如 Go 的 rune）用 32 位整数存储码点。

为了在存储和传输中节约空间，Unicode 引入了多种编码方式，其中最常用的是 UTF-8。UTF-8 使用 1~4 个字节表示一个码点：
对 ASCII 范围内的字符使用 1 字节，与 ASCII 完全兼容；
对其他字符使用 2~4 字节，既节约空间，又能自我同步。

编码后，字符被存储为一串字节（[]byte）。要恢复原始字符，就需要解码这些字节得到对应的码点（rune）。

当我们输出字符时，程序会把 rune 重新编码为 UTF-8 字节写入标准输出流。终端程序读取这些字节，解码出码点后，根据系统字体库查找该码点对应的字形（glyph），再通过字体渲染引擎绘制到屏幕上。这样，字符最终以像素的形式呈现在我们面前。


## 复合数据类型

### Slice
 并行赋值的执行顺序：先计算右侧所有表达式的值，并将它们暂时存储在临时变量中。再将这些临时值依次赋给左侧变量。(用于反转数据)

unicode.IsSpace(rune) : 当你传入9，10，11，32时均会返回True，因为根据Unicode它们对应的符号均为空格。

Go 的设计者刻意去掉了指针算术，原因是为了：保证内存安全；避免非法访问；使垃圾回收器更容易跟踪引用。

Go 的切片传参是「值传递」而非「引用传递」
首先，Go 的切片底层结构大致如下：
```go
type slice struct {
    array unsafe.Pointer // 底层数组指针
    len   int
    cap   int
}
```
当你把一个切片传入函数时，Go 会 拷贝这个结构体，但它的 array 指针仍然指向同一个底层数组。
也就是说：
底层数组是共享的 ✅
切片的 len 和 cap 是独立副本 ❌

###  结构体  
  
  对于结构体的指针，可以直接使用点操作符，编译器会自动调用解引用。  

  一个结构体可能同时包含导出和未导出的成员。如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。


### JSON

将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。
在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。




## 函数

## 函数值的底层实现机制
1.Go 的函数值在本质上是一个轻量级的函数指针封装结构，Go 的函数值是一个指向函数代码的引用结构，内部保存代码地址（fn）和可选的环境指针（env）。

2.函数值结构中存储着一个函数指针(fn)，指向实际可执行代码的位置，当函数“捕获”外部变量时（比如返回一个内部函数），
这个函数值不仅要保存代码地址，还要保存被捕获的变量环境(env)。并且GO的闭包并不是复制外部变量的值，其实是引用外部变量的地址。
当形成闭包时，捕获的外部变量会被移动到堆上，并由 env 指针引用。调用闭包时，会额外传入环境指针，实现“记忆状态”的能力。

3.闭包捕获的是变量地址，而不是值。因此多个闭包共享同一个外部变量时，会互相影响。

4.编译器有时会对 不捕获变量的匿名函数 做静态化优化，
使其行为与普通函数几乎相同（不分配 env）。Go 函数调用支持 内联（inline）优化，
即使是函数值调用，只要编译器能确定 fn 指向的函数体，也可能内联。

5.底层实现结构大致如下:
```go
type closure struct {
    fn uintptr       // 指向函数代码
    env *environment // 指向捕获的变量环境
}

type environment struct {
    count *int
}

```
### 函数命名

函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。
函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。
每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参。
遇到没有函数体的函数声明，这表示该函数不是以Go实现的。


### 递归

有关outline函数，传入了一个string切片，命名为stack,当作栈来使用，这是可行的，因为切片的删除操作可以模仿栈的后入先出，在Golang中没有特定的栈类型
需要注意的是：有关切片被作为参数传入的时候，是值传递的方式传递的，切片内部的len,app是复制的，但是底层的数组指针还是指向同一个数组，但是当使用切片的
append操作时，**如果超出了切片的cap，那么就会重新分配数组，这个时候，函数内部的切片就和原切片无关了，因为此时他们指向不同的数组。**


### 多返回值

strings.Fields 是 Go 标准库 strings 包中的一个函数，作用是：按照空白字符切分字符串，并返回一个字符串切片。
它的行为类似于其他语言里的 split()，但更智能：会自动识别各种空白字符（空格、换行符、制表符等），并且自动忽略多余的空白


### 错误

1.在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。

2.对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。
如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。

3.error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。

4.**有少部分函数在发生错误时，仍然会返回一些有用的返回值**。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。

5.编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。


### 函数值

### 有关nil与空切片的区别
nil 切片：ptr == nil，len == 0，cap == 0
空切片：ptr 指向某个零长度数组（地址非空），len == 0，cap == 0
并且GO遵从‘零值可用’原则，对nil与空切片进行range循环，均不会报错，会直接退出循环。
``` go
a := []string//a为nil
b := []string{}//b为空切片
c := make([]string,0)//c为空切片
```
