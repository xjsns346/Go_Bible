

# MarkDown 要点:
1. ctrl + shift + v   可以在vs code 预览文件效果
2. ``` 代码 ```  来展示多行代码。


# Go模块系统

## go.mod 是什么
1. go.mod 是 Go 模块系统的核心配置文件。
它的作用是:记录当前项目的模块路径、Go 版本、依赖包及其版本。
2. Go 从 1.11 开始引入模块（module）系统，用来取代 GOPATH 机制。

3. 
| 功能               | 说明                                  |
| :--- | :---|
| **1️⃣ 声明模块名**    | 指定当前项目的唯一模块路径（通常对应仓库路径）             |
| **2️⃣ 管理依赖版本**   | 明确记录项目依赖了哪些包及其版本                    |
| **3️⃣ 控制替换规则**   | 可用 `replace` 或 `exclude` 手动修改依赖源或版本 |
| **4️⃣ 指定 Go 版本** | 确保代码按指定 Go 版本语义编译                   |
| **5️⃣ 支持可重复构建**  | 不论谁在哪个机器上构建，都能获得相同的依赖和结果            |


4. 常见命令与 go.mod 的关系

| 命令 |	作用 |
| :--- | :--- |
|**go mod init <module-name>**|	创建 go.mod 文件并初始化模块|
|**go mod tidy**|自动添加缺失的依赖，删除未使用的依赖|
|**go mod download**|	下载 go.mod 里列出的依赖|
|**go mod edit**|	手动编辑 go.mod 内容（高级用法）|

5. 配套文件：go.sum
Go 会自动生成一个 go.sum 文件，用来记录每个依赖模块的哈希值。
它保证每次下载的依赖都完全一致，防止被篡改。



# Go 学习笔记



## 入门

gofmt工具格式化时按照字母顺序对包名排序。  

Go语言只有for循环这一种循环语句。

空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。

当你运行 go run xxx.go 的时候，Go 会先 编译 .go 文件 → 生成一个 .exe → 把它放到 AppData\Local\go-build 这个缓存目录。
这个.exe文件是一个临时可执行文件，下次运行.go文件时会创建一个新的.exe文件

map的迭代顺序并不确定,类似于python的字典类型

os.Stdin,os.Stdout,os.Stderr都是*os.file类型的值

程序员通常不需要关心 int/uint 的精确大小，只要用它们表示“一般整数”就行。
当处理网络协议、文件格式时，才用 int32、uint16 等。

### 查找重复的行
-小文件（配置文件、少量数据） → os.ReadFile，简单方便。
-大文件（日志、数据集） → bufio.Scanner 或 bufio.Reader，节省内存。  

在 Go 里，只有 package main 且包含 func main() 函数的包，才能编译成一个可执行文件。

### 获取URL
在同一作用域里，:= 遇到旧变量时：
1.如果左边有新变量 → 旧变量被复用，新变量被定义。
2.如果左边全是旧变量 → 编译报错。

| 特性         | `io.ReadAll`           | `io.Copy`            |
| --- | --- | --- |
| 返回结果*  | `[]byte`（全部数据）         | 字节数（已写到 `dst`）       |
| 内存占用* | 和数据大小成正比，可能很大          | 固定缓冲区（约 32KB）        |
| 适用场景   | 小文件、小 HTTP 响应，结果需要直接操作 | 大文件、大流式数据，结果要写到文件/网络 |
| 是否阻塞内存 | 是，会占住内存直到数据全读完         | 否，边读边写，流式处理          |


## 程序结构

### 类型
许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印，但是当使用%g时，不会调用string方法。
在圣经的例子中，%g没有调用string方法，因为%g 专门用于 浮点数格式化，而不是通用字符串格式化。


### 变量
flag 包就是 Go 官方提供的 命令行参数解析工具，适合写小工具、脚本或服务时用来配置参数。  

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这个选择并不是由用var还是new声明变量的方式决定的。

### 包和文件

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释,如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释。如果包注释很大，通常会放到一个独立的doc.go文件中。

一个目录下的所有 .go 文件必须属于同一个包。

在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

按照惯例，一个包的名字和包的导入路径的最后一个字段相同。

当一个较大位宽的整数类型转换为较小位宽时，高位会被截断，只保留低位。



## 基础数据类型

### 整型

取模运算符%仅用于整数间的运算。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。  

x &^ y 的作用就是：把 x 里，y 为 1 的位置清零，其他位置保持不变。(二进制)

1. 左移运算符 <<
表达式：x << n
含义：把 x 的二进制位整体 向左移动 n 位，右边空出来的位用 0 填充。
👉 数学效果：相当于 乘以 2ⁿ（前提是不溢出）。

2. 右移运算符 >>
表达式：x >> n
含义：把 x 的二进制位整体 向右移动 n 位。
左边空出来的位，规则要分情况：
无符号整数：高位补 0（逻辑右移）。
有符号整数：Go 里会补 符号位（算术右移）。
👉 数学效果：相当于 除以 2ⁿ，取整。  

|名称|符号|
|---|---|
|AND|&|
|OR|\||
|XOR|^|
|左移|<<|
|右移|>>|

## 字符串
1. strings.Map(mapping,string)是一个对处理字符串非常方便的函数。

2. Go 中的 string 是：
```go
  type string struct {
    data *byte   // 指向底层字节数组
    len  int     // 字节长度
  }
```
也就是说，字符串就是UTF-8 编码的字节序列。
每个字符（Unicode code point）被编码为 1~4 个字节。

3. 对字符串使用len函数时的一些误区:
- len(s1)：返回的是字节数，因为 Go 中的字符串是以字节的方式存储的。
- range 遍历：range 在遍历字符串时，会自动将每个字符转换成 rune，因此你可以直接得到每个 Unicode 字符（rune）及其对应的字节索引（i）。
- 转换为 rune 切片：你可以将字符串转换为 []rune 切片来更方便地按字符访问，因为每个 rune 都代表一个完整的 Unicode 字符。

### *有关字符串存储与打印的一些小知识*
由于世界上的语言繁多，以及存在大量符号，原有的 ASCII 编码（仅 128 个字符）无法满足需求，因此产生了 Unicode 标准，为世界上每个字符分配了唯一的 码点（Code Point）。

Unicode 码点的范围是从 U+0000 到 U+10FFFF，最多需要 21 位二进制表示。为了方便实现，许多语言（如 Go 的 rune）用 32 位整数存储码点。

为了在存储和传输中节约空间，Unicode 引入了多种编码方式，其中最常用的是 UTF-8。UTF-8 使用 1~4 个字节表示一个码点：
对 ASCII 范围内的字符使用 1 字节，与 ASCII 完全兼容；
对其他字符使用 2~4 字节，既节约空间，又能自我同步。

编码后，字符被存储为一串字节（[]byte）。要恢复原始字符，就需要解码这些字节得到对应的码点（rune）。

当我们输出字符时，程序会把 rune 重新编码为 UTF-8 字节写入标准输出流。终端程序读取这些字节，解码出码点后，根据系统字体库查找该码点对应的字形（glyph），再通过字体渲染引擎绘制到屏幕上。这样，字符最终以像素的形式呈现在我们面前。

* * *

## 复合数据类型

### Slice
1. 并行赋值的执行顺序：先计算右侧所有表达式的值，并将它们暂时存储在临时变量中。再将这些临时值依次赋给左侧变量。(用于反转数据)

2. unicode.IsSpace(rune) : 当你传入9，10，11，32时均会返回True，因为根据Unicode它们对应的符号均为空格。

3. Go 的设计者刻意去掉了指针算术，原因是为了：保证内存安全；避免非法访问；使垃圾回收器更容易跟踪引用。

4. Go 的切片传参是「值传递」而非「引用传递」当你把一个切片传入函数时，Go 会 拷贝这个结构体，但它的 array 指针仍然指向同一个底层数组。

-  底层数组是共享的 
- 切片的 len 和 cap 是独立副本 
- Go 的切片底层结构大致如下：
```go
type slice struct {
    array unsafe.Pointer // 底层数组指针
    len   int
    cap   int
}
```

5. 当使用append方法时，有一些注意事项:
  - append 的基本语法`slice = append(slice, elem1, elem2, ...)`
第一个参数：要被扩展的切片（可以为 nil）。
后续参数：要追加的一个或多个元素。
返回值是一个新的切片（可能共用原底层数组，也可能新建）。
  - 使用 ... 展开符：append(a, b...) 表示把切片 b 的所有元素展开后逐一追加。
  - Go 在底层做了容量增长优化：当 cap < 1024 时：通常是 翻倍增长；当 cap >= 1024 时：增长率约为 1.25倍（即 +25%）。


###  结构体  
  
  对于结构体的指针，可以直接使用点操作符，编译器会自动调用解引用。  

  一个结构体可能同时包含导出和未导出的成员。如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。


### JSON

将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。
在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。




## 函数


### 函数命名

函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。
函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。
每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参。
遇到没有函数体的函数声明，这表示该函数不是以Go实现的。


### 递归

有关outline函数，传入了一个string切片，命名为stack,当作栈来使用，这是可行的，因为切片的删除操作可以模仿栈的后入先出，在Golang中没有特定的栈类型
需要注意的是：有关切片被作为参数传入的时候，是值传递的方式传递的，切片内部的len,app是复制的，但是底层的数组指针还是指向同一个数组，但是当使用切片的
append操作时，**如果超出了切片的cap，那么就会重新分配数组，这个时候，函数内部的切片就和原切片无关了，因为此时他们指向不同的数组。**


### 多返回值

strings.Fields 是 Go 标准库 strings 包中的一个函数，作用是：按照空白字符切分字符串，并返回一个字符串切片。
它的行为类似于其他语言里的 split()，但更智能：会自动识别各种空白字符（空格、换行符、制表符等），并且自动忽略多余的空白


### 错误

1.在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。

2.对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。
如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。

3.error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。

4.**有少部分函数在发生错误时，仍然会返回一些有用的返回值**。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。

5.编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。


### 函数值

### 函数值的底层实现机制
1.Go 的函数值在本质上是一个轻量级的函数指针封装结构，Go 的函数值是一个指向函数代码的引用结构，内部保存代码地址（fn）和可选的环境指针（env）。

2.函数值结构中存储着一个函数指针(fn)，指向实际可执行代码的位置，当函数“捕获”外部变量时（比如返回一个内部函数），
这个函数值不仅要保存代码地址，还要保存被捕获的变量环境(env)。并且GO的闭包并不是复制外部变量的值，其实是引用外部变量的地址。
当形成闭包时，捕获的外部变量会被移动到堆上，并由 env 指针引用。调用闭包时，会额外传入环境指针，实现“记忆状态”的能力。

3.闭包捕获的是变量地址，而不是值。因此多个闭包共享同一个外部变量时，会互相影响。

4.编译器有时会对 不捕获变量的匿名函数 做静态化优化，
使其行为与普通函数几乎相同（不分配 env）。Go 函数调用支持 内联（inline）优化，
即使是函数值调用，只要编译器能确定 fn 指向的函数体，也可能内联。

5.底层实现结构大致如下:
```go
type closure struct {
    fn uintptr       // 指向函数代码
    env *environment // 指向捕获的变量环境
}

type environment struct {
    count *int
}

```

### 有关nil与空切片的区别
nil 切片：ptr == nil，len == 0，cap == 0
空切片：ptr 指向某个零长度数组（地址非空），len == 0，cap == 0
并且GO遵从‘零值可用’原则，对nil与空切片进行range循环，均不会报错，会直接退出循环。
``` go
a := []string//a为nil
b := []string{}//b为空切片
c := make([]string,0)//c为空切片
```

### 匿名函数

1.  `link, err := resp.Request.URL.Parse(a.Val)` 这一行代码很常见，尤其在编写网络爬虫或解析 HTML 链接时经常出现。
    作用: 基于当前网页的 URL，解析 HTML 标签中的相对链接，生成完整的绝对 URL。


2. Go 的 `for d := range dirs` 循环中，d 变量在每次迭代中是被重用的，不是每次新建一个。所以当闭包中需要调用变量**d**的时候，要创建一个新的变量来储存*d*的值


### 可变参数

1. 变长参数`...`只能出现在函数的参数列表的最后一个位置。如果你在其他位置（比如中间或开头）使用 `...`，就会出现这个错误。

  原因:Go 语言的参数列表是按顺序解析的。固定参数会先被解析，而变长参数（...）必须位于最后，因为它表示“剩下的所有参数”。这确保了 Go 编译器可以正确区分固定数量的参数和变长参数，并将多余的参数放入切片中。如果将 ... 放在中间或开头，编译器就无法确定哪些是固定的参数，哪些是变长参数，因此会报错。


2. 
